\section{Artificial Intelligence: A Modern Approach}

\subsection{Chapter 1-5 (July 22)}

\subsubsection*{Discussions}
\begin{itemize}
\item variants of $\text{A}^*$ (limited memory, weighted, $LRTA^*$)
\item And-or search trees (their different uses)
\item alpha-beta pruning (work through an example)
\end{itemize}

\subsubsection*{Topics for Review}
\begin{itemize}
\item BFS, DFS, $\text{A}^*$, limited-memory $\text{A}^*$
\item Iterative deepening DFS
\item Heuristics for $\text{A}^*$
\item Simulated annealing, evolutionary algorithms
\item And-or search trees
\item $\text{LRTA}^*$
\item Minimax
\item Alpha-beta pruning
\item Expectimax
\end{itemize}

\subsection{Chapter 6-8 (July 25)}
\subsection*{Discussions}
\begin{itemize}
\item K-consistency -- generalization of individual consistency
\item Reduction to binary constraints -- introduce variables, dual graphs
\item path consistency -- remove pairs or singletons
\item backjumping -- completeness; backjumping undoes any variables that were set after the node you backjump to
\item Forward Checking $\subset$ Arc Consistency
\item 6.5 -- favorite section for questions
\begin{itemize}
  \item Tree Structured CSP -- enforce directed arc consistency $\rightarrow$ no backtracking needed
  \item Cut sets -- iterate over all possible assignments to the cut set; cut set leaves remaining graph as tree
  \item Tree decomposition -- junction tree for CSPs! -- graph with subsets of variables, tree structured solver enforces variable consistency. 
\end{itemize}
\item Basic logic modus ponens/and resolution
\item models $\rightarrow$ possible worlds, simplest inference = model-checking -- $\alpha \implies \beta$ iff $M(\alpha) \subseteq M(\beta)$.
\item Forward Chaining -- Horn Clauses + Definite Clauses; important idea is the lhs of implications are positive conjunctions. That property saves backtracking over incorrect assignments. 
\item DPLL -- DFS with Heuristics; what do we need to know
\item Satisfiablility Problems are usually easy
\item frame problem, fluents, 
\item belief states -- represent 'belief' as things that could be true
\item SATPlan -- be super verbose or problems arise
\item object/relations/functions
\item quantifiers $\exists$, $\forall$
\end{itemize}

\subsection*{Topics for Review}
\begin{itemize}
\item CSPs -- know them
\item consistency: node, arc, path, strong-k
\item heuristics: minimum remaining value, degree, least constrained
\item backjumping/conflict directed
\item local search
\item Tree Structured- CSPs
\item knowledge base
\item syntax
\item possible worlds/models
\item entailment
\item horn clauses/forward chaining
\item (logical) state estimation
\end{itemize}

\subsection{Chapter 9-12, 17 (July 29)}
\subsection*{Discussions}
\begin{itemize}
\item Propositionalization of first-order logic statements
\item Generalized Modus Ponens, unification
\item Forward chaining in FOL - NP hard, can use heuristics and incremental forward chaining
\item Backward chaining
\item Resolution - conversion to CNF (including Skolem functions), refutation-completeness
\item Equality in FOL - demodulation, paramodulation
\item PDDL - states, actions
\item Planning as a search problem, heuristics
\item Planning graphs, heuristics, \textsc{Graphplan}
\item Partially ordered plans
\item Critical path method, heuristics
\item Hierarchical planning, high-level actions, angelic semantics
\item Nondeterminism in planning - percept augmentation to PDDL, belief stats as conjunctions of positives, replanning
\item Multiagent planning
\end{itemize}

\subsection*{Topics for Review}
\begin{itemize}
\item Inference in FOL - Generalized Modus Ponens, unification, forward/backward chaining, resolution
\item PDDL, planning problems, search strategies, planning graphs
\item Partially ordered plans
\item Scheduling - critical path method, hierarchical planning, nondeterminism in planning
\end{itemize}
